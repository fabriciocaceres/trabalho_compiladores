options{  JDK_VERSION = "1.5";  static = true;  DEBUG_PARSER = true;}PARSER_BEGIN(EG1)package parser;import recovery.*;public class EG1{  public static void main(String args []) throws ParseException  {    EG1 parser = new EG1(System.in);    while (true)    {      System.out.println("Reading from standard input...");      System.out.print("digite :");      try      {        SimpleNode n = EG1.Start();        n.dump("");      }      catch (Exception e)      {        System.out.println("NOK.");        System.out.println(e.getMessage());        EG1.ReInit(System.in);      }      catch (Error e)      {        System.out.println("Oops.");        System.out.println(e.getMessage());        break;      }    }  }  static public String im(int x)  {    int k;    String s;    s = tokenImage [x];    k = s.lastIndexOf("\"");    try    {      s = s.substring(1, k);    }    catch (StringIndexOutOfBoundsException e)    {}    return s;  }  static Token lastError = null;  static boolean eof; // vari√°vel que indica se EOF foi alcan√ßado
  // o m√©todo abaixo consome tokens at√© alcan√ßar um que perten√ßa ao conjunto
  // de sincroniza√ß√£o
  static void consumeUntil(RecoverySet g, ParseException e, String met) throws ParseEOFException, ParseException  {    Token tok;    System.out.println();    System.out.println("*** " + met + " ***");    System.out.println("     Conjunto de sincronizaÁ„o: " + g);    if (g == null) throw e; // se o conjunto √© null, propaga a exce√ß√£o
    tok = getToken(1); // pega token corrente
    while (!eof)    { // se n√£o chegou ao fim do arquivo
      if (g.contains(tok.kind))      { //achou um token no conjunto
        System.out.println("     Encontrado token de sincronizaÁ„o: " + im(tok.kind));        break;      }      System.out.println("     Ignorando o token: " + im(tok.kind));      getNextToken(); // pega pr√≥ximo token       
      tok = getToken(1);      if (tok.kind == EOF && !g.contains(EOF))  // fim da entrada?   
      eof = true;    }    if (tok != lastError)    {      System.out.println(e.getMessage());      lastError = tok;    }    if (eof) throw new ParseEOFException("Encontrei EOF onde n„o deveria.");  }}PARSER_END(EG1)SKIP :{  " "| "\r"| "\t"| < "//" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    ) >| < "/*" (~[ "*" ])* "*"    (      ~[ "/" ] (~[ "*" ])* "*"    )*    "/" >}TOKEN : /* PALAVRAS RESERVADAS*/{  < PARA : "para" >| < SE : "se" >| < SENAO : "!se" >| < RETORNO : "retorno" >| < INI : "ini" >| < FUNCAO : "funcao" >| < MOSTRAR : "mostrar" >| < ENTER : "\n" >}TOKEN : /* LIMITADORES */{  < ABRE_PARENTESES : "(" >| < FECHA_PARENTESES : ")" >| < ABRE_CHAVE : "{" >| < FECHA_CHAVE : "}" >| < VIRGULA : "," >| < PONTO_VIRGULA : ";" >| < DELIMITAR_TEXTO : "'" >}TOKEN : /* TIPOS DE ID */{  < TIPO_INTEIRO : "inteiro" >| < TIPO_REAL : "real" >| < TIPO_TEXTO : "texto" >}TOKEN : /* TIPOS OPERADORES */{  < MAIOR : ">" >| < MENOR : "<" >| < MENOR_IGUAL : "<=" >| < MAIOR_IGUAL : ">=" >| < IGUAL : "==" >| < DIFERENTE : "!=" >| < ATRIBUIR : "=" >}TOKEN : /* TIPOS OPERADORES MATEMATICOS*/{  < MAIS : "+" >| < MENOS : "-" >}TOKEN : /* LETRAS E NUMEROS*/{  < LETRA_MAIUSCULA : [ "A"-"Z" ] >| < LETRA_MINUSCULA : [ "a"-"z" ] >| < NUMERO :    < DIGITO >  | < DIGITO > "." < DIGITO >>| < #DIGITO : ([ "0"-"9" ])+ >}SimpleNode Start() :{}{  main()  {    return jjtThis;  }}int main() :{  RecoverySet g = First.main;}{  try  {    (criaFuncao() (<ENTER>)*)*  ini() pontoVirgula() (<ENTER>)* (criaFuncao())*  }  catch (ParseException e)  {    consumeUntil(g, e, "main");  }  {    return 0;  }}void ini() :{  RecoverySet g = First.ini;}{  try  {    < INI > abreParenteses() fechaParenteses() (<ENTER>)* abreChave() (<ENTER>)* (comando())* fechaChave()  }  catch (ParseException e)  {    consumeUntil(g, e, "ini");  }}/* PALAVRAS RESERVADAS*/void funcao() :{}{  < FUNCAO >}void retorno() :{}{  < RETORNO >}void mostrar() :{}{  < MOSTRAR >}void para() :{}{  < PARA >}void se() :{}{  < SE >}void seNao() :{}{  < SENAO >}void enter(): {}{  (<ENTER>)*}/* PALAVRAS RESERVADAS*//* LIMITADORES */void abreParenteses() :{}{  < ABRE_PARENTESES >}void fechaParenteses() :{}{  < FECHA_PARENTESES >}void abreChave() :{}{  < ABRE_CHAVE >}void fechaChave() :{}{  < FECHA_CHAVE >}void virgula() :{}{  < VIRGULA >}void pontoVirgula() :{}{  < PONTO_VIRGULA >}void delimitaTexto() :{}{  < DELIMITAR_TEXTO >}/* LIMITADORES *//* TIPOS DE ID */void tipoID() :{  RecoverySet g = First.tipoID;}{  try  {    tipoInteiro()  | tipoReal()  | tipoTexto()  }  catch (ParseException e)  {    consumeUntil(g, e, "tipoID");  }}void tipoInteiro() :{}{  < TIPO_INTEIRO >}void tipoReal() :{}{  < TIPO_REAL >}void tipoTexto() :{}{  < TIPO_TEXTO >}/* FIM TIPOS DE ID *//* TIPOS OPERADORES */void operadorLogico() :{  RecoverySet g = First.operadorLogico;}{  try  {    menor()  | maior()  | menorIgual()  | maiorIgual()  | diferente()  | igual()  }  catch (ParseException e)  {    consumeUntil(g, e, "operadorLogico");  }}void menor() :{}{  < MENOR >}void maior() :{}{  < MAIOR >}void menorIgual() :{}{  < MENOR_IGUAL >}void maiorIgual() :{}{  < MAIOR_IGUAL >}void diferente() :{}{  < DIFERENTE >}void igual() :{}{  < IGUAL >}void atribuir() :{}{  < ATRIBUIR >}/* FIM TIPOS OPERADORES *//* TIPOS OPERADORES MATEMATICOS*/void increDecrementa():{  RecoverySet g = First.increDecrementa;}{  try  {    id() maisOuMenos()| maisOuMenos() id()  }  catch (ParseException e)  {    consumeUntil(g, e, "increDecrementa");  }}void maisOuMenos():{  RecoverySet g = First.increDecrementa;}{  try  {    mais()| menos()  }  catch (ParseException e)  {    consumeUntil(g, e, "maisOuMenos");  }}void mais():{}{  <MAIS>}void menos():{}{  <MENOS>}/* FIM TIPOS OPERADORES MATEMATICOS*//* LETRAS E NUMEROS*/void numero() :{}{  < NUMERO >}void letra() :{}{	(letraMinuscula() | letraMaiuscula() )+}void letraMinuscula() :{}{  < LETRA_MINUSCULA >}void letraMaiuscula() :{}{  < LETRA_MAIUSCULA >}void texto() :{  RecoverySet g = First.texto;}{  try  {    delimitaTexto() (letra()  | numero()) + delimitaTexto()  }  catch (ParseException e)  {    consumeUntil(g, e, "texto");  }}/* LETRAS E NUMEROS*//* ID */void id() :{  RecoverySet g = First.id;}{  try  {  	letraMinuscula()  	(   	 letra() 	 | numero() 	 )*  }  catch (ParseException e)  {    consumeUntil(g, e, "id");  }}/* COMANDOS*/void chamaFuncao() :{  RecoverySet g = First.chamaFuncao;}{  try  {    funcao() id() abreParenteses() (id()  | texto()  | numero()) * fechaParenteses() pontoVirgula()  }  catch (ParseException e)  {    consumeUntil(g, e, "chamaFuncao");  }}void declaracaoID() :{  RecoverySet g = First.declaracaoID;}{  try  {    tipoID() listaID()  }  catch (ParseException e)  {    consumeUntil(g, e, "declaracaoID");  }}void listaID() :{  RecoverySet g = First.listaID;}{  try  {    (id() (atribuir() (id()  | texto()  | numero()))? (virgula())? )+ pontoVirgula()  }  catch (ParseException e)  {    consumeUntil(g, e, "listaID");  }}void repeticao() :{  RecoverySet g = First.repeticao;}{  try  {    para() abreParenteses() numero() virgula() id() virgula() numero() virgula() increDecrementa() fechaParenteses() abreChave()(<ENTER>)*    (comando()) * fechaChave()  }  catch (ParseException e)  {    consumeUntil(g, e, "repeticao");  }}void condicionalSe() :{  RecoverySet g = First.condicionalSe;}{  try  {    se() abreParenteses() expressao() fechaParenteses() (<ENTER>)* abreChave() (<ENTER>)* (comando()) * fechaChave()     (condicionalSeNao())?  }  catch (ParseException e)  {    consumeUntil(g, e, "condicionalSe");  }}void condicionalSeNao() :{  RecoverySet g = First.condicionalSeNao;}{  try  {    seNao()  abreChave() (<ENTER>)* (comando()) * fechaChave()  }  catch (ParseException e)  {    consumeUntil(g, e, "condicionalSeNao");  }}void expressao() :{  RecoverySet g = First.expressao;}{  try  {    (id()  | numero()  | texto()) operadorLogico() (id()  | numero()  | texto())  }  catch (ParseException e)  {    consumeUntil(g, e, "expressao");  }}void imprimir() :{  RecoverySet g = First.imprimir;}{  try  {    mostrar() abreParenteses() (texto()  | id()) fechaParenteses() pontoVirgula()  }  catch (ParseException e)  {    consumeUntil(g, e, "imprimir");  }}void retornoFuncao() :{  RecoverySet g = First.retornoFuncao;}{  try  {    retorno() abreParenteses() (id()  | texto()  | numero()) fechaParenteses() pontoVirgula()  }  catch (ParseException e)  {    consumeUntil(g, e, "retornoFuncao");  }}void iniciaId() :{  RecoverySet g = First.iniciaId;}{  try  {    id() atribuir() (numero()  | id()  | texto()) pontoVirgula()  }  catch (ParseException e)  {    consumeUntil(g, e, "iniciaId");  }}void criaFuncao() :{  RecoverySet g = First.criaFuncao;}{  try  {    funcao() id() abreParenteses()  (tipoID() id() (virgula())?)* fechaParenteses() (<ENTER>)*    abreChave() (<ENTER>)*    (comando()) *     (ini() (<ENTER>)* )? fechaChave()  }  catch (ParseException e)  {    consumeUntil(g, e, "criaFuncao");  }}void comando() :{  RecoverySet g = First.comando;}{  try  {   (      repeticao() (<ENTER>)*	  | declaracaoID() (<ENTER>)*	  | condicionalSe() (<ENTER>)*	  | chamaFuncao() (<ENTER>)*	  | imprimir() (<ENTER>)*	  | retornoFuncao() (<ENTER>)*	  | iniciaId() (<ENTER>)*  )   }  catch (ParseException e)  {    consumeUntil(g, e, "comando");  }}