options
{
  JDK_VERSION = "1.5";
  static = true;
  DEBUG_PARSER = true;
}

PARSER_BEGIN(EG1) 
package parser;
import recovery.*;
public class EG1
{
  public static void main(String args []) throws ParseException
  {
    EG1 parser = new EG1(System.in);
    while (true)
    {
      System.out.println("Reading from standard input...");
      System.out.print("digite :");
      try
      {
        SimpleNode n = EG1.Start();
        n.dump("");
        
      }
      catch (Exception e)
      {
        System.out.println("NOK.");
        System.out.println(e.getMessage());
        EG1.ReInit(System.in);
      }
      catch (Error e)
      {
        System.out.println("Oops.");
        System.out.println(e.getMessage());
        break;
      }
    }
  }


  static public String im(int x)
  {
    int k;
	String s;
    s = tokenImage[x];
    k = s.lastIndexOf("\"");
    try {
      s = s.substring(1,k);
    }
   catch (StringIndexOutOfBoundsException e)
	   {}
   return s;
  }
	
  static Token lastError = null;
  static boolean eof;    // variável que indica se EOF foi alcançado
	
  // o método abaixo consome tokens até alcançar um que pertença ao conjunto
  // de sincronização
  static void consumeUntil(RecoverySet g,
	                 ParseException e,
	                 String met) throws ParseEOFException,
	                                    ParseException
  {
	Token tok;
	System.out.println();
	System.out.println("*** " + met + " ***");
	System.out.println("     Conjunto de sincronização: " + g);
		
	if (g == null) throw e; // se o conjunto é null, propaga a exceção
	
	tok = getToken(1); // pega token corrente
	while ( ! eof )	{ // se não chegou ao fim do arquivo
	  if ( g.contains(tok.kind)) {//achou um token no conjunto
	    System.out.println("     Encontrado token de sincronização: " + 
	                       im(tok.kind));
	    break;
	  }
	  System.out.println("     Ignorando o token: " + im(tok.kind));
	  getNextToken();     // pega próximo token       
      tok = getToken(1);
	  if (tok.kind == EOF && ! g.contains(EOF) ) // fim da entrada?   
	      eof = true;
	}
    if ( tok != lastError)  {
	  System.out.println(e.getMessage());
	  lastError = tok;
	   
	}
	if ( eof )
	  throw new ParseEOFException("Encontrei EOF onde não deveria.");
  }
}

PARSER_END(EG1)

SKIP :
{
  " "
| "\r"
| "\t"
| < "//" (~[ "\n", "\r" ])*
    (
      "\n"
    | "\r"
    | "\r\n"
    ) >
	| < "/*" (~[ "*" ])* "*"
    	(
      		~[ "/" ] (~[ "*" ])* "*"
    	)*
    "/" >
}

TOKEN : /* Declaracao de variaveis */
{
	< INTEIRO: "int">
|	< FLUTUANTE: "float">
|	< STRING: "varchar">
|	< NUMERO: (<DIGITO>)+ ( "." (<DIGITO>)+ )?>
|	< #DIGITO: ["0" -"9"]>
|   < VIRGULA: "," >
|	< ATRIBUICAO: "<-">
|	< DELIMITAR_VARCHAR: "'" >
| < FIM: "fim" >
}

TOKEN : /* def inicio programa */
{
  < INICIO : "inicio" >
| < PONTO_VIRG: ";" >
| < ID: ["a" - "z" , "A" - "Z"](["a" - "z" , "A" - "Z" , "0" - "9", "_"])*>
| < ENTER : "\n" >

}

SimpleNode Start() :
{}
{
  main()
  {
    return jjtThis;
  }
}


int main() :
{
RecoverySet g = First.main;
}
{
 try { 
    < INICIO > id() < PONTO_VIRG > < ENTER >

	(declaracaoVariaveis())+

	(atribuicao())+ < ENTER >

	 < FIM > < ENTER >
    }
    catch (ParseException e)
    {
       consumeUntil(g, e, "main");
    }

	
	{ return 0;}
}


void declaracaoVariaveis() : {
  RecoverySet g = First.declaracaoVariaveis;
} 
/* Definio do que acontece na parte de declarao de variaveis
   <declaraes> ::=  <tipo>  <lista_identificadores> ;
   <lista_identificadores> ::= <identificador> ;| <identificador>, <lista_identificadores> ;

*/
{

  try  {     tipo()	(identificador_variaveis())+  <PONTO_VIRG> < ENTER >
  } catch (ParseException e)
    {
       consumeUntil(g, e, "declaracaoVariaveis");
    }

}

void tipo() #TIPOVAR:
{}
{   < INTEIRO >
|  < FLUTUANTE >
|  < STRING >
}

void identificador_variaveis() : { } 
{
	 <VIRGULA> id()
	| id()
}


void atribuicao() :
{
  RecoverySet g = First.atribuicao;
}
{
  try  {
	 id() <ATRIBUICAO> (<NUMERO> | <DELIMITAR_VARCHAR><ID><DELIMITAR_VARCHAR>) <PONTO_VIRG>
  } catch (ParseException e)
    {
       consumeUntil(g, e, "atribuicao");
    }
 	
}

void id() #ID :
{}
{
  < ID > 
}
